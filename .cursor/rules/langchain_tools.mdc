---
description: Standards and patterns for developing LangChain tools 
globs: src/Tools/*.ts,src/Tools/*.test.ts
alwaysApply: false
---
- **Tool Structure Requirements:**
  - **Use `tool()` function** from `@langchain/core/tools` for all tool implementations
  - **Export as named constant** with descriptive name ending in `Tool` (e.g., `pokemonCardAddTool`)
  - **Define Zod schema** for input validation with detailed descriptions
  - **Use `.nullish()` instead of `.optional()`** for optional parameters (GPT models handle nullish better)
  - **Include comprehensive tool description** explaining purpose and usage

- **Schema Definition Patterns:**
  ```typescript
  // ✅ DO: Use Zod with detailed descriptions and nullish for optional fields
  const schema = z.object({
    query: z.string().describe('Search query for finding relevant information'),
    limit: z.number().nullish().describe('Maximum number of results to return (default: 10)'),
    category: z.enum(['web', 'images', 'news']).nullish().describe('Search category filter')
  });
  
  type ToolInput = z.infer<typeof schema>;
  
  // ❌ DON'T: Use .optional() as GPT models don't handle optional arguments well
  const badSchema = z.object({
    query: z.string(),
    limit: z.number().optional(), // Avoid this
  });
  ```

- **Tool Implementation Standards:**
  - **Extract tool context** using `getToolContext(config)` for accessing services
  - **Handle errors gracefully** with descriptive error messages for the bot
  - **Return user-friendly strings** that can be displayed in chat
  - **Use async/await** for all asynchronous operations
  - **Validate inputs** using the Zod schema before processing
  - **Tool names** referenced in other tool’s descriptions must not be hardcoded, but imported as constant

- **Tool Configuration:**
  ```typescript
  // ✅ DO: Proper tool configuration with inline description
  export const myTool = tool(
    async (input: ToolInput, config: LangGraphRunnableConfig): Promise<string> => {
      const context = getToolContext(config);
      // Implementation here
    },
    {
      name: 'toolName',           // camelCase, descriptive
      description: 'Clear description of what this tool does and when to use it.',
      schema,                     // Zod schema defined above
    },
  );
  ```

- **Context Usage Patterns:**
  ```typescript
  // ✅ DO: Extract services from context
  const context = getToolContext(config);
  const userId = context.userId;
  const service = context.someService;
  
  // ❌ DON'T: Access services directly without context
  const service = container.get(SomeService);
  ```

- **ToolContext Security (CRITICAL):**
  - **NEVER expose full Config object** in ToolContext - major security risk
  - **Only include specific properties** tools actually need (principle of least privilege)
  - **Use structured objects** instead of cluttering context with many individual properties
  
  ```typescript
  // ✅ DO: Secure, minimal context exposure
  export interface ToolContext {
    chatId: bigint;
    userId: bigint;
    telegramService: TelegramService;
    identityByChatId: Map<bigint, Identity>;      // Only needed map, not full Config
    identities: {                                 // Structured object
      schiParmelae: SchiParmelaeIdentity;
      emulator: EmulatorIdentity;
    };
  }
  
  // ❌ DON'T: Expose entire config object (security vulnerability)
  export interface ToolContext {
    config: Config;  // Contains sensitive data like API keys!
    // ... other fields
  }
  ```

- **Error Handling:**
  - **Return error messages as strings** rather than throwing exceptions
  - **Provide context** in error messages for user understanding
  - **Handle edge cases** like missing data or API failures gracefully
  - **Use constants** for common error messages to ensure consistency

- **Tool Registration (CRITICAL):**
  - **MUST register in ChatGptAgentService** - Tools are non-functional until added to the `tools` array in `ChatGptAgentService.ts`
  - **Import the tool** in `ChatGptAgentService.ts` 
  - **Add to tools array** alongside other tools like `pokemonCardAddTool`
  - **Test integration** - Verify the tool is actually available to the agent, not just unit tested
  
  ```typescript
  // ✅ DO: Register tool in ChatGptAgentService.ts
  import { myNewTool } from './Tools/myNewTool.js';
  
  @injectable()
  export class ChatGptAgentService {
    private readonly tools: (StructuredTool | Tool)[] = [
      new Calculator(),
      diceTool,
      myNewTool, // <-- Add your tool here
      pokemonCardAddTool,
    ];
  }
  
  // ❌ DON'T: Create tool without registering it (renders tool completely non-functional)
  ```

- **Testing Requirements:**
  - **Create `.test.ts` file** for every tool implementation
  - **Test with mock context** using fakes for external dependencies
  - **Test error scenarios** including invalid inputs and service failures
  - **Verify Zod schema validation** with various input combinations
  - **Test tool description and name** are properly configured
  - **Test integration** - Ensure tool is registered and available (not just unit functionality)

- **Testing Patterns:**
  ```typescript
  // ✅ DO: Use createTestToolConfig for context mocking
  import { createTestToolConfig, ToolContext } from '../ChatGptAgentService.js';
  
  describe('myTool', () => {
    let mockService: ServiceFake;
    let config: { configurable: ToolContext };
    
    beforeEach(() => {
      mockService = new ServiceFake();
      config = createTestToolConfig({
        chatId: BigInt('123456789'),
        userId: BigInt('987654321'),
        myService: mockService,
        // Only provide the context properties your tool actually needs
      });
    });
    
    it('should handle success case', async () => {
      const result = await myTool.invoke({ input: 'test' }, config);
      expect(result).toBe('Expected result');
      expect(mockService.methodCallArgs).toEqual(['test']);
    });
    
    it('should handle error case', async () => {
      mockService.shouldThrowError = true;
      const result = await myTool.invoke({ input: 'test' }, config);
      expect(result).toMatch(/Error:/);
    });
  });
  ```

- **File Organization:**
  - **Tool files** in `src/Tools/` directory
  - **Factories are DEPRECATED and FORBIDDEN** - All tool dependencies must be provided via the config argument (dependency injection)
  - **When migrating legacy tools**: Delete factory classes, update ChatGptAgentService to inject dependencies via ToolContext, update all tests
  - **Inline descriptions** for most tools (preferred for simplicity)
  - **Constants file** only for descriptions/messages that require typographical apostrophes (’) (e.g., Pokémon tools use `texts.ts`).
  - **Related tools** grouped by functionality (e.g., Pokémon tools, GitHub tools)

- **Modern Tool Migration Pattern:**
  ```typescript
  // ✅ DO: Modern tool function pattern
  export const myTool = tool(
    (input: MyToolInput, config: LangGraphRunnableConfig): string => {
      const context = getToolContext(config);
      // Use context.someService directly
      return context.someService.process(input.data);
    },
    {
      name: 'my-tool',
      description: 'Tool description',
      schema: mySchema,
    },
  );
  
  // ❌ DON'T: Legacy class-based tools with factories
  export class MyTool extends StructuredTool {
    constructor(private someService: SomeService) { super(); }
    // ... legacy implementation
  }
  
  export class MyToolFactory {
    create(): MyTool { return new MyTool(this.someService); }
  }
  ```

- **Documentation Standards:**
  - **JSDoc comments** for exported tools explaining purpose and usage
  - **Parameter descriptions** in Zod schema are primary documentation
  - **Example usage** in tool description when helpful
  - **Link to related tools** or services in comments

- **Performance Considerations:**
  - **Lazy load** expensive resources only when needed
  - **Cache results** when appropriate (following existing patterns)
  - **Limit API calls** and implement reasonable timeouts
  - **Handle rate limiting** gracefully with user feedback

Follow [core.mdc](mdc:.cursor/rules/core.mdc) for general TypeScript and testing standards.
