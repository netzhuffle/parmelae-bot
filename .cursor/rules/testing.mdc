---
description: Project rules and best practices for writing and executing tests 
globs: *.test.ts
alwaysApply: false
---

# Testing Standards

- **Every TypeScript file must have a corresponding .test.ts file** in the same folder
- **Prefer fakes over mocks**, placed in `/src/Fakes/` (see [testing_fakes.mdc](mdc:.cursor/rules/testing_fakes.mdc))
- **Only fake I/O operations** (DB, network); unit and integration test all business logic
- **Keep fakes simple** and void of any business logic (because there are no tests for tests!)
- **Test files should follow pattern**: `[originalFileName].test.ts`

## Bun:Test Implementation

**All test files MUST import required functions from `bun:test`:**

```typescript
// ✅ DO: Import all needed testing functions
import { describe, beforeEach, it, expect } from 'bun:test';

// ✅ DO: Import additional functions as needed
import { describe, beforeAll, afterAll, beforeEach, afterEach, it, test, expect, mock, spyOn } from 'bun:test';
```

## Test Structure

- **Follow arrange, act, assert pattern**
- **Keep tests simple** for easy correctness judgment
- **No business logic in tests** - repetition is fine, focus on readability
- **Always verify:**
  - Code runs without errors
  - Correct methods are called with correct arguments
  - Correct return values are returned or set
- **Avoid testing full, long strings** – test for relevant parts only

## Testing Philosophy: Behavior Over Implementation

- **✅ DO: Test behavior and results** - Verify what functions do, not how they do it
- **✅ DO: Test through public APIs** - Test exported functions and their observable effects
- **✅ DO: Test error conditions** - When splitting error handling, ensure test cases exist for all error paths
- **✅ DO: Test integration points** - Verify that functions work correctly together
- **✅ DO: Remove useless tests** - If a test only verifies internal constants or implementation details without testing behavior, remove it

- **❌ DON'T: Test internal implementation details** - Don't test private constants, internal variables, or implementation-specific logic
- **❌ DON'T: Export internals just for testing** - Don't export private constants, types, or functions solely to make them testable
- **❌ DON'T: Test pure internals** - If testing an internal constant doesn't verify actual behavior, test the function results instead
- **❌ DON'T: Test implementation details** - Focus on what the code does, not how it does it internally

**Example - Testing Behavior vs Internals:**

```typescript
// ❌ DON'T: Test internal constants directly
describe('RARITY_MAP', () => {
  it('should map rarities correctly', () => {
    expect(RARITY_MAP['C Pocket']).toBe('♢'); // Testing internal constant
  });
});

// ✅ DO: Test behavior through function results
describe('parseSet', () => {
  it('should correctly map all Pokewiki rarities to project symbols', async () => {
    const parsedSet = await parseSet(url);
    expect(parsedSet.cards[0]?.rarity).toBe('♢'); // Testing actual behavior
  });
});
```

**Example - Error Handling:**

```typescript
// ✅ DO: Test all error conditions when splitting error handling
it('should throw error if textarea element is missing', async () => {
  // Test missing element case
});

it('should throw error if edit source is too short', async () => {
  // Test content too short case
});
```

## Fake Timers for Timer-Based Code (Bun 1.3.4+)

**Use fake timers** to test code that relies on `setTimeout`, `setInterval`, and other timer-based APIs without waiting for real time to pass.

```typescript
// ✅ DO: Use fake timers for timer-based code
import { describe, it, expect, jest, beforeEach, afterEach } from 'bun:test';

describe('ServiceWithTimers', () => {
  beforeEach(() => {
    // Call useFakeTimers() once - do not call it again in individual tests
    jest.useFakeTimers();
  });

  afterEach(() => {
    jest.useRealTimers();
  });

  it('should schedule correctly', () => {
    // Set time using setSystemTime() - do not call useFakeTimers() again
    jest.setSystemTime(new Date('2024-01-15T12:00:00Z'));
    
    // Trigger code that uses setTimeout
    service.scheduleAction();
    
    // Verify timer was scheduled
    const timerCount = jest.getTimerCount();
    expect(timerCount).toBeGreaterThan(0);
    
    // Advance time and verify behavior
    jest.advanceTimersByTime(5000); // Advance 5 seconds
    jest.runAllTimers(); // Run all pending timers
    
    // Assertions
  });
});
```

**Available fake timer methods:**
- `jest.useFakeTimers(options?)` - Enable fake timers, optionally setting current time with `{ now: number | Date }`. **Call this once in `beforeEach`, not in individual tests.**
- `jest.setSystemTime(date)` - Set the current time for fake timers. **Use this in individual tests to change time, not `useFakeTimers()` again.**
- `jest.useRealTimers()` - Restore real timers
- `jest.advanceTimersByTime(ms)` - Advance all timers by specified milliseconds
- `jest.advanceTimersToNextTimer()` - Advance to the next scheduled timer
- `jest.runAllTimers()` - Run all pending timers
- `jest.runOnlyPendingTimers()` - Run only currently pending timers
- `jest.getTimerCount()` - Get the number of pending timers
- `jest.clearAllTimers()` - Clear all pending timers
- `jest.isFakeTimers()` - Check if fake timers are active

**Important Pattern:**
```typescript
// ✅ DO: Call useFakeTimers() once in beforeEach
beforeEach(() => {
  jest.useFakeTimers();
});

// ✅ DO: Use setSystemTime() in individual tests to change time
it('should work at specific time', () => {
  jest.setSystemTime(new Date('2024-01-15T12:00:00Z'));
  // Test code
});

// ❌ DON'T: Call useFakeTimers() multiple times with different options
beforeEach(() => {
  jest.useFakeTimers(); // First call
});

it('should work', () => {
  jest.useFakeTimers({ now: date }); // ❌ Don't call again!
});
```

**Promise Chain Handling:**
When testing code that uses `.then()` chains with fake timers, wait for promise microtasks to complete:

```typescript
// ✅ DO: Wait for promise chains after advancing timers
jest.runAllTimers();
await new Promise<void>((resolve) => {
  setImmediate(() => {
    setImmediate(() => {
      resolve();
    });
  });
});

// Now assertions will see completed promise chains
expect(fake.methodCallArgs.length).toBeGreaterThan(0);
```

## Test Execution Commands

When done with implementation, test writing, and refactoring, run the full validation suite:

```bash
bun run format && bun run schema-format
bun run typecheck && bun run typecheck-all
bun run lint && bun run validate-yaml
bun test
```

**Always run the complete sequence** - if any step fails, fix the issue and restart from the beginning. Never skip steps.

## Test Examples from Codebase

**Basic Unit Test:**
```typescript
// From src/Tools/diceTool.test.ts
import { describe, beforeEach, it, expect } from 'bun:test';
import { diceTool } from './diceTool.js';

describe('diceTool', () => {
  beforeEach(() => {
    // Setup code
  });

  it('should roll dice correctly', async () => {
    // Arrange, Act, Assert
  });
});
```

Follow [testing_fakes.mdc](mdc:.cursor/rules/testing_fakes.mdc) for fake implementation patterns and [error_handling.mdc](mdc:.cursor/rules/error_handling.mdc) for testing error scenarios.