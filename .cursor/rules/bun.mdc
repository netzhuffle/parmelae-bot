---
description: Bun runtime and package manager patterns, best practices, and compatibility guidelines
globs: **/*
alwaysApply: false
---

# Bun Development Patterns

## Runtime & Package Management

### **Installation Commands**
```bash
# ✅ DO: Use bun install for dependency installation
bun install

# ✅ DO: Use production script for deployment
bun run install-prod  # Equivalent to: bun install --production --frozen-lockfile

# ✅ DO: Use bunx instead of npx
bunx task-master
```

### **Development & Production Execution**
```bash
# ✅ DO: Direct TypeScript execution with Bun
bun src/index.ts

# ✅ DO: Use bun run for package.json scripts
bun run typecheck
bun run checks
```

## **Bun-Native API Optimizations**

Prefer [Bun APIs](https://bun.sh/docs/runtime/bun-apis) over Node.js APIs or external dependencies where available.

### **Environment Variables**
✅ **Native `.env` loading** - Bun automatically loads environment variables without requiring `dotenv`
```typescript
// ✅ DO: Use Bun.env instead of process.env + dotenv
const apiKey = Bun.env.API_KEY;

// ❌ DON'T: Import and configure dotenv
import * as dotenv from 'dotenv';
dotenv.config();
const apiKey = process.env.API_KEY;
```

### **Shell Operations**
✅ **Bun $ Shell API** - Cross-platform shell operations with template literals
```typescript
// ✅ DO: Use Bun $ Shell for command execution
import { $ } from 'bun';

const result = await $`/path/to/script`.text();
// Or with error handling:
try {
  const output = await $`command arg1 arg2`.text();
  return output.trim();
} catch (error) {
  const stderr = (error as { stderr?: string })?.stderr?.trim() ?? 'Unknown error';
  return `Error: ${stderr}`;
}

// ❌ DON'T: Use Node.js child_process
import { exec } from 'child_process';
exec('command', (error, stdout, stderr) => { /* ... */ });
```

### **File I/O Operations**
✅ **Bun.file() API** - Native file operations with async/await
```typescript
// ✅ DO: Use Bun.file() for reading files
const yamlFile = Bun.file('config.yaml');
const content = await yamlFile.text();

// For dependency injection contexts requiring async:
container.bind(SYMBOL).toDynamicValue(async () => {
  const file = Bun.file('resources/data.yaml');
  return await file.text();
});

// ❌ DON'T: Use Node.js fs module
import { readFileSync } from 'fs';
const content = readFileSync('config.yaml', 'utf-8');
```

### **HTTP Requests**
✅ **Native fetch API** - Built-in web standard HTTP client
```typescript
// ✅ DO: Use native fetch (already available in Bun)
const response = await fetch('https://api.example.com/data');
const data = await response.json();

// ✅ DO: Use appropriate SDKs for services
const openai = new OpenAI(); // OpenAI SDK
const octokit = new Octokit(); // GitHub API

// ❌ DON'T: Add unnecessary HTTP client dependencies
// Remove unused axios, node-fetch, etc.
```

## **Configuration Patterns**

### **Dependencies Optimization**
✅ **Minimal dependency footprint** by removing Node.js-specific packages
- ❌ Remove: `dotenv`, `nodemon`, `ts-node`, unused HTTP clients
- ✅ Keep: Bun-compatible packages and necessary SDKs
- ✅ Add: `@types/bun` for TypeScript support

## **Performance Benefits**

- 🚀 **Faster startup** - Direct TypeScript execution
- 📦 **Smaller bundle** - Fewer dependencies required  
- 🔧 **Simpler config** - Built-in TypeScript, environment loading
- ⚡ **Better DX** - Native shell operations, unified toolchain

See [testing.mdc](mdc:.cursor/rules/testing.mdc) for Bun testing patterns and [core.mdc](mdc:.cursor/rules/core.mdc) for general development workflow integration.