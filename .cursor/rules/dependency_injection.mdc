---
description: Dependency injection patterns and best practices 
globs: *.ts
alwaysApply: false
---
# Dependency Injection Patterns

## Core Principles

- **Inversion of Control:** Use Inversify container to manage dependencies
- **Testability:** All dependencies should be injectable for easy mocking
- **Single Responsibility:** Each class should have a focused purpose
- **Decoupling:** Components should depend on abstractions, not concretions

## Injectable Class Pattern

- **Service Classes:**
  ```typescript
  import { injectable } from 'inversify';

  @injectable()
  export class ChatGptService {
    constructor(
      private readonly messageRepository: MessageRepository,
      private readonly userRepository: UserRepository,
      private readonly gptModelsProvider: GptModelsProvider,
    ) {}

    // Methods
  }
  ```

## Inversify Autobind Configuration

The project uses `autobind: true` in the Inversify container configuration.

**What this means:**
- Classes decorated with `@injectable()` are **automatically registered** in the container
- No explicit `container.bind()` call is needed for these classes
- Constructor dependencies are automatically resolved

**When explicit binding IS needed:**
- Binding interfaces to concrete implementations
- Using factory functions or dynamic values (e.g., `toDynamicValue()`)
- Binding constants or symbols (e.g., `POKEMON_TCGP_YAML_SYMBOL`)
- Overriding default autobind behavior

**Example - Autobind (no manual binding):**
```typescript
@injectable()
export class PokemonTcgPocketService {
  constructor(private readonly repo: PokemonTcgPocketRepository) {}
}
// ✓ Both classes automatically registered, no container.bind() needed
```

**Example - Manual binding (dynamic value):**
```typescript
container.bind(POKEMON_TCGP_YAML_SYMBOL).toDynamicValue(async () => {
  const { default: sets } = await import('../resources/tcgpcards.yaml');
  return sets;
});
// ✓ Manual binding needed for dynamic import
```

## Common Anti-Patterns

- ❌ **DON'T:** Create dependencies manually with `new`
- ❌ **DON'T:** Use service locator pattern
- ❌ **DON'T:** Create circular dependencies
- ❌ **DON'T:** Inject too many dependencies (>5-7 suggests refactoring needed)

- ✅ **DO:** Use constructor injection for all dependencies
- ✅ **DO:** Keep dependencies focused and minimal
- ✅ **DO:** Use interfaces for better testability when appropriate
- ✅ **DO:** Follow single responsibility principle
