generator client {
  provider   = "prisma-client"
  output     = "../src/generated/prisma"
  engineType = "client"
  runtime    = "bun"
}

datasource db {
  provider = "sqlite"
  url      = "file:./sqlite.db"
}

model Chat {
  id                BigInt             @id
  type              String
  title             String?
  username          String?
  firstName         String?
  lastName          String?
  messages          Message[]
  scheduledMessages ScheduledMessage[]
}

model ChatEntryMessagesUsers {
  message   Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  messageId Int
  user      User    @relation(fields: [userId], references: [id])
  userId    BigInt

  @@id([messageId, userId], name: "id")
}

model DateTimeSetting {
  setting  String   @id
  dateTime DateTime
}

model Message {
  id                      Int                      @id @default(autoincrement())
  telegramMessageId       Int?
  chat                    Chat                     @relation(fields: [chatId], references: [id])
  chatId                  BigInt
  from                    User                     @relation(fields: [fromId], references: [id])
  fromId                  BigInt
  sentAt                  DateTime
  editedAt                DateTime?
  replyToMessage          Message?                 @relation("ReplyToMessage", fields: [replyToMessageId], references: [id], onDelete: SetNull)
  replyToMessageId        Int?
  text                    String
  imageFileId             String?
  stickerFileId           String?
  newChatMembers          ChatEntryMessagesUsers[]
  replies                 Message[]                @relation("ReplyToMessage")
  toolCalls               Json?
  toolMessages            ToolMessage[]
  messageAfterToolCalls   Message?                 @relation("MessageAfterToolCalls", fields: [messageAfterToolCallsId], references: [id])
  messageAfterToolCallsId Int?
  toolCallMessages        Message[]                @relation("MessageAfterToolCalls")

  @@unique([telegramMessageId, chatId])
  @@index([chatId])
  @@index([chatId, sentAt])
  @@index([chatId, id])
  @@index([sentAt])
  @@index([fromId])
  @@index([replyToMessageId])
}

model ToolMessage {
  id         Int     @id @default(autoincrement())
  message    Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  messageId  Int
  toolCallId String
  text       String

  @@index([messageId])
  @@index([toolCallId])
}

model ScheduledMessage {
  id          Int      @id @default(autoincrement())
  chat        Chat     @relation(fields: [chatId], references: [id])
  chatId      BigInt
  from        User     @relation(fields: [fromId], references: [id])
  fromId      BigInt
  sendAt      DateTime
  scheduledAt DateTime @default(now())
  text        String

  @@index([sendAt])
  @@index([chatId])
  @@index([fromId])
}

model User {
  id                BigInt                   @id
  isBot             Boolean
  firstName         String
  lastName          String?
  username          String?
  languageCode      String?
  messages          Message[]
  chatEntryMessages ChatEntryMessagesUsers[]
  scheduledMessages ScheduledMessage[]
  cardOwnerships    PokemonCardOwnership[]

  @@index([isBot])
  @@index([username])
}

model PokemonSet {
  id       Int              @id @default(autoincrement())
  key      String           @unique
  name     String
  boosters PokemonBooster[]
  cards    PokemonCard[]

  @@index([name])
}

model PokemonBooster {
  id           Int           @id @default(autoincrement())
  name         String
  set          PokemonSet    @relation(fields: [setId], references: [id])
  setId        Int
  cards        PokemonCard[]
  godPackCards PokemonCard[] @relation("GodPackBooster")

  @@unique([setId, name])
  @@index([setId])
}

model PokemonCard {
  id               Int                    @id @default(autoincrement())
  name             String
  set              PokemonSet             @relation(fields: [setId], references: [id])
  setId            Int
  number           Int
  rarity           Rarity?
  isSixPackOnly    Boolean                @default(false)
  godPackBooster   PokemonBooster?        @relation("GodPackBooster", fields: [godPackBoosterId], references: [id])
  godPackBoosterId Int?
  boosters         PokemonBooster[]
  ownership        PokemonCardOwnership[]

  @@unique([setId, number])
  @@index([setId])
  @@index([rarity])
  @@index([name])
  @@index([isSixPackOnly])
  @@index([godPackBoosterId])
}

model PokemonCardOwnership {
  id        Int             @id @default(autoincrement())
  card      PokemonCard     @relation(fields: [cardId], references: [id])
  cardId    Int
  user      User            @relation(fields: [userId], references: [id])
  userId    BigInt
  status    OwnershipStatus
  createdAt DateTime        @default(now())
  updatedAt DateTime        @updatedAt

  @@unique([cardId, userId])
  @@index([userId])
  @@index([cardId])
  @@index([status])
}

/// Card rarity definitions for Pokemon TCG Pocket.
/// Each rarity has a corresponding symbol used in YAML data.
enum Rarity {
  /// Standard diamond rarity (symbol: ♢)
  ONE_DIAMOND
  /// Foil variant of ONE_DIAMOND (symbol: ♢✦)
  /// Triggers FOUR_CARDS_WITH_GUARANTEED_EX when present
  ONE_DIAMOND_FOIL
  /// Standard diamond rarity (symbol: ♢♢)
  TWO_DIAMONDS
  /// Foil variant of TWO_DIAMONDS (symbol: ♢♢✦)
  /// Triggers FOUR_CARDS_WITH_GUARANTEED_EX when present
  TWO_DIAMONDS_FOIL
  /// Standard diamond rarity (symbol: ♢♢♢)
  THREE_DIAMONDS
  /// Foil variant of THREE_DIAMONDS (symbol: ♢♢♢✦)
  /// Triggers FOUR_CARDS_WITH_GUARANTEED_EX when present
  THREE_DIAMONDS_FOIL
  /// EX card rarity (symbol: ♢♢♢♢)
  FOUR_DIAMONDS
  /// Illustration rare (symbol: ☆)
  ONE_STAR
  /// Special illustration rare (symbol: ☆☆)
  TWO_STARS
  /// Immersive special illustration (symbol: ☆☆☆)
  THREE_STARS
  /// Shiny rare (symbol: ✸)
  ONE_SHINY
  /// Higher tier shiny (symbol: ✸✸)
  TWO_SHINY
  /// Crown rare (symbol: ♛)
  CROWN
}

enum OwnershipStatus {
  OWNED
  NOT_NEEDED
}
